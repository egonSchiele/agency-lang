node main() {
  msg = input("> ");
  importRecipe(msg);
}

type Url = {
  url:string # website url;
}

type Recipe = {
  title:string;
  ingredients: string[];
  instructions: string;
}

node importRecipe(msg) {
  url :: Url
  url = `extract the url from this message: ${msg}`

  html :: string
  html = fetch(url.url)

  recipe :: Recipe
  recipe = `extract the recipe from this html: ${html}`

  exit({
    type: "confirm_recipe",
    recipe
    });

  /* This causes the graph run to finish immediately, returning this value as the result.
  The backend code can then pass this to the frontend, which will look at the type and show
  the user a confirmation UI accordingly.

  They can then pass back whatever arbitrary object to an API endpoint, which can then either
  take the action specified by the object, such as creating this ingredient, pass it to a
  different agent who will then take care of creating the ingredient, or pass it to the same agent,
  passing the response as part of the initial state, and that agent can then use that to take a
  different path through the code, depending on whether the user confirmed or rejected the creation.

  The point is, unlike LandGraph, the language doesn't need to handle the human-in-the-loop aspect
  at all because that is conflating different concepts. The graph part can just be pure, with no
  side effects. It takes an input, does some stuff, and returns an output. There is no internal
  state to the graph.

  Well then, you may ask, isn't it useful to have the history of messages saved so the conversation
  can pick up where it left off? Yes, it is, but the graph doesn't need to be involved in that part
  One option is that when the graph returns its result, it returns all of its current internal
  state as a side effect. The caller of that graph can then choose to save that state somewhere
  and input it as a parameter when creating the graph, so the graph can essentially pick up where
  it left off.

  Then, it's the caller's responsibility to figure out whether it wants to persist those messages and,
  if so, how to do that; it also handles creating and using a thread ID to persist those messages.
*/
}