categorize -> import_recipe | create_recipe | create_ingredient

categorize msg = `Please categorize this message #{msg}`, { category: import_recipe | create_recipe | create_ingredient }
  case result of
    | import_recipe -> import_recipe
    | create_recipe -> create_recipe
    | create_ingredient -> create_ingredient


import_recipe flag = do
  case flag of
    | null -> get_html -> parse -> match_ingredients -> confirm_ingredients
    | confirm_ingredient -> confirm_ingredients

// function overload = different edges in graph
// could also determine the graph by examining each function's return types
// confirm_ingredients -> confirm_recipe
// confirm_ingredients -> show_cancellation

confirm_recipe -> done
confirm_recipe -> show_cancellation

get_html :: string -> string
get_html msg = `get the html contents from this link: #{msg}`

type Ingredient = {
  name: string;
  amount: string;
}

type ParsedRecipe = {
  ingredients: Ingredient[];
  recipe: string;
}

parse :: string -> ParsedRecipe
parse html = `parse a recipe from this html: #{html}`

match_ingredients :: ParsedRecipe
match_ingredients = foo

// handles HITL: confirm, edit, reject
confirm_ingredients i = do
  response = confirm("do these ingredients look correct?", i)
  case response of
    | confirm -> confirm_recipe i
    | edit new_i -> confirm_recipe new_i
    | reject -> show_cancellation

// eg confirm and show_cancellation are external functions
// but also confirm needs to implement HITL and therefore send a flag
// so at the start, we jump to this step

confirm msg i = return { msg, ingredients: i, flag: confirm_ingredient }

// examples

main = `print "hello world"`
main arg1 = `print the #{arg1}th fibonacci number`

/* handles:
- some built-in tools (like print)
- retry
- structured output
- different models
- images? audio? user input?
- how to tell about other available tools?
- how to connect to externally defined functions?
  - simplest way is everything external is a fetch call
  - but what if an external func wants to call an agent func?
  - alternatively, connect to an mcp server. Look up what info an mcp server exposes
- also keeps track of the thread it itself?

other nice-to-haves:
- makes it easier to test an agent
- built-in support for authn/z
  - eg for fetch, what if I want a safelist of urls? or a blocklist?
  - I think any authn/z function would have to be external, by necessity.
    eg if we need to look up the user in the db. In that case, avoiding a
    network call would be nice. So functions are natively local or endpoints?
  - could an agent do oauth/is that needed?
- per-func, could we control model used, number of responses, number of retries?
*/

// eg endpoint func
// interesting, a fetch call as a first-class citizen
checkUser = POST /user

// fibonacci
fib 1 = 1
fib 2 = 1
fib n = `fib(n - 1) + fib(n - 2)`

baseInstructions = @CLAUDE.md
docs = `fetch "http://www.phaser.io"`

addTile = `Use BaseTile.ts as a template`

main = do
  instructions = user_input
  ```
  help the user with their phaser.io game. Follow this input:
  #{instructions}

  instructions: #{baseInstructions}
  docs: #{docs}
  ```

// function = tool
// function call = fetch call
// tools can call agents, agents can call tools
// type = structured output
// code generates ui <-> ui generates code
main uses [addTile]

/*
for chatbot, what would be useful?
- prompts
- knowledge base articles
- cases where we definitely return a specific response (eg "agent" or "talk to a human")
- tools

stats would be useful too
*/