
export async function {{{functionName:string}}}(args, __metadata={}) {
    const __stack = __stateStack.getNewState();
    const __step = __stack.step;
    const __self = __stack.locals;
    const __graph = __metadata?.graph || graph;
    const statelogClient = __metadata?.statelogClient || __statelogClient;

    // if being called from a node, we'll pass in threads.
    // if being called as a tool, we won't have threads, but we'll create an empty ThreadStore here.
    // obv none of these messages will connect to a thread the user can see.
    const __threads = __metadata?.threads || new ThreadStore();

    // args are always set whether we're restoring from state or not.
    // If we're not restoring from state, args were obviously passed in through the code.
    // If we are restoring from state, the node that called this function had to have passed
    // these arguments into this function call.
    // if we're restoring state, this will override __stack.args (which will be set),
    // but with the same values, so it doesn't matter that those values are being overwritten.
    const __params = [{{{argsStr}}}];
    (args).forEach((item, index) => {
      __stack.args[__params[index]] = item;
    });


    {{{functionBody}}}
}
