
graph.node("{{{name}}}", async (state): Promise<any> => {
    const __messages: Message[] = state.messages || [];
    const __graph = state.__metadata?.graph || graph;
    const statelogClient = state.__metadata?.statelogClient || __statelogClient;
    
    // if `state.__metadata?.__stateStack` is set, that means we are resuming execution
    // at this node after an interrupt. In that case, this is the line that restores the state.
    if (state.__metadata?.__stateStack) {
      __stateStack = structuredClone(state.__metadata.__stateStack);
      
      // clear the state stack from metadata so it doesn't propagate to other nodes.
      state.__metadata.__stateStack = undefined;
    }

    // either creates a new stack for this node,
    // or restores the stack if we're resuming after an interrupt,
    // depending on the mode of the state stack (serialize or deserialize).
    const __stack = __stateStack.getNewState();
    
    // We're going to modify __stack.step to keep track of what line we're on,
    // but first we save this value. This will help us figure out if we should execute
    // from the start of this node or from a specific line.
    const __step = __stack.step;

    const __self: Record<string, any> = __stack.locals;

    // If we're resuming after an interrupt, these will be set.
    // There should be a cleaner way to handle this,
    // instead of littering this scope with these variables
    const __interruptResponse: InterruptResponseType | undefined = state.__metadata?.interruptResponse;
    const __toolCall: Record<string, any>|undefined = __stateStack.other?.toolCall;

    // TODO pretty sure this isn't needed, check and remove
    if (state.__metadata?.state?.global) {
      __global = state.__metadata.state.global;
    }

    {{#hasParam}}
    
    const __params = {{{paramNames}}};
    
    // Any arguments that were passed into this node,
    // save them onto the stack, unless we are restoring the stack after an interrupt,
    // in which case leave as is
    if (state.data !== "<from-stack>") {
      (state.data).forEach((item, index) => {
        __stack.args[__params[index]] = item;
      });
    }
    {{/hasParam}}
    {{{body}}}
    
    // this is just here to have a default return value from a node if the user doesn't specify one
    return { ...state, data: undefined };
});
